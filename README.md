- 6.15 实现使用LRU算法淘汰旧缓存
- 本分布式缓存系统的缓存是存储在内存中的，当内存达到上限的时候需要淘汰缓存记录
- 淘汰的策略有FIFO(First In First Out)、LFU(Least Frequently Used)
- 分别只考虑了时间和频率，缺点是前者遇到存在大量时间上属于先进队列中但是被高频访问的元素时就会因为高频的出入队操作而产生较大开销
- 后者的缺点是遇到曾经被使用过很多次但最近一段时间几乎不被使用的元素就无法淘汰
- LRU算法综合考虑了时间和频率,淘汰最近被访问最少的元素，
- LRU.go 1.查找功能 Get √ 2.缓存移除功能 RemoveOldest √ 3.新增/修改 Add √
- 编写了LRU算法用于缓存超限的时候淘汰缓存队列ll中的节点的算法
- 每次将进行了Get获取操作或者Add新增/修改操作的节点通过MovetoFront移动到队首
- 超限时RemoveOldest方法淘汰Back()获取到的指针指向的队列元素然后调用删除节点时的回调函数OnEvicted

- 6.16 实现单机并发cache、缓存数据类型ByteView
- 基于之前的lru.cache加上锁sync.Mutex封装了一个新结构体用于实现并发安全
- 对lru.cache的add函数和get函数使用写锁实现并发安全
- 并发安全:指的是多个goroutine同时进行读/写的时候不会产生预期外的结果、数据不一致、崩溃/异常等问题

- 6.18 完成HTTP服务端
- 编写Group数据结构(构造、通过key从主缓存获取数据、主缓存未命中的时候获取数据再存储到主缓存中的方法)
- 其中创建和读取Group存在读写锁
- Getter接口定义Get方法作为本地获取不到数据时调用的方法
- 每个Group表示一个独立的缓存命名空间，缓存不同类型的数据，避免仅使用键进行存储所遇到的冲突问题
- test 6.16-6.18之间的内容

- 6.28 完成一致性哈希
- 为了让特定的